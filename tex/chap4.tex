\chapter{Annotation Service}

\section{Objective of the Annotation Service}
As described in \ref{sec2_as}, the goal of the AS is to provide a user with the possibility to:
\begin{enumerate}[(1)]
	\item view A WSI
	\item annotate a WSI
	\item manage made annotations
\end{enumerate}

In order to achieve objective (1) - (3), a GUI needs to be deployed which supports the user in working on those tasks. (3) also adds the need for file persistence management.

During the development process it became clear that supporting only DZI as input format was impractical for the real life environment of the AS. Therefore, the need to support proprietary formats as well arose. The proprietary formats should be supported without implementing separate handling for each one and without creating a vendor lock-in or platform restriction\footnote{See subsection \ref{sec1_researchObjective}(i), \ref{sec1_researchObjective}(ii) and \ref{sec2_openFormats}}.


\section{Methodology}
As stated in 2.1, most vendors have proprietary image formats and their own implementation of a viewer for those, thus creating a vendor lock-in. Further do vendors often support only Windows platforms, ignoring other operating systems\cite{Cornish13}\cite{DICOM10}\cite{Farahanil15}. To avoid this, a solution must be found that is independent of operating system and vendor.

Independence from an operating system can be achieved by using web technologies, especially when running an application in a web browser\cite{Tseytlin14}, since those are supported by all modern operating systems. 

Chapter \ref{sec3_cs} already established a service to convert WSIs of various formats into the DZI format, solving the problem of multiple proprietary formats. But, as the development process has shown, this is not enough. Therefore, a solution must be established, with which proprietary formats can be handled as well. The use of OpenSlides python interface provides the functionality of generating individual Deep Zoom tiles from slide objects without a complete conversion via a DZI wrapper, which can be used to wrap proprietary image formats and serve them to a web browser as if they would be DZI\cite{web:openslide}.

Because of those reasons, the AS will be implemented as a web browser application. 


\subsection{Functionality of the Annotation Service}
\label{sec4_functions}
The goal of viewing a WSI (1) is a straight forward task. (2) and (3) are more elusive. For that reason, this subsection elaborates on the functionality needed to help achieve those objectives.

Annotations will be created by drawing directly onto the viewed WSI. If the user spots a region of interest, a contour can be drawn around it. This can  either be done in \emph{free hand} or \emph{polygon mode}. In free hand mode, the contour will be drawn along the path of the mouse pointer, until the mode is disabled again. Upon deactivation, the contour will be closed. In polygon mode, the user can place coordinates which will be connected from one to another in the order they are placed in. A contour in this mode considers to be closed, once a point on the contour is clicked a second time. A marked region of interest is simply called \emph{region} from this point on.

The information what a region is surrounded by can be as valuable as the information about the region itself\cite{Bankman00}. Therefore, every region will have a \emph{context} trait, which lists every label of regions it touches, crosses, surrounds or is surrounded by (see fig. \ref{fig4_contextregions}).

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.5]{img/contextregions.png}
		\caption{Example of context regions (B, C are context of A; A, C are context of B; A, B are context of C; D has no context region)}
		\label{fig4_contextregions}
	\end{center}
\end{figure}
% TODO: add figure about context regions

Another way of creating regions will be so called \emph{points of interest} (POI)\nmc{POI}{Point of Interest}. A POI will be placed with a mouse click. After that, an external script will be invoked to run an automated segmentation in the proximity of the POI and return with a contour which will be marked as region. The segmentation approaches may differ drastically in different scenarios\cite{Liu12}, therefore the script will be interchangeable\footnote{There are many different ways of how to approach the topic of segmentation (e.g. \cite{Qi12}, \cite{Sharma16}, \cite{Wienert12}, \cite{Angulo10} for cell segmentation alone). Writing a fully working segmentation script is worth another thesis by itself, therefore only a dummy implementation will be delivered with this work.}.

Each region has a \emph{label} associated to it. A label is a predefined string, which describes what the region just created shows. The labels available will be determined through a \emph{label dictionary}, which is a container that offers a list of strings to select from. This approach guarantees a unified labeling, independent of a specific WSI or pathologist. The option to choose between multiple available label dictionaries opens up the possibility of creating dictionaries which are specialized on certain cases or studies. Again, to keep up labeling integrity, labels can only be selected from one dictionary per WSI.

Users will be able to create new, empty dictionaries, if the need arises. Furthermore, they will be able to add entries to existing and new dictionaries alike, to further advance or specialize them. To delete single entries or whole dictionaries, file access to the server is necessary. This is due to the fact, that knowledge can by added without direct negative consequences. Deleting existing knowledge influences all WSIs on which this knowledge was used, may it be as a label or a whole dictionary.

To support the user in annotating a WSI, a distance measurement tool will be usable as well. This tool can measure the distance between 2 pixels in $\mu$m.


\subsection{Parts of the Annotation Service}
The AS is implemented in 2 parts. Those are the Annotation Service Server (ASS)\nmc{ASS}{Annoation Service Server} and the Annotation Service Viewer (ASV)\nmc{ASV}{Annotation Service Viewer}.

This is because of the \emph{same-origin policy} (SOP)\nmc{SOP}{Same-Origin Policy}. SOP is a security concept of the web application security model. It prevents a direct access to files, if the parent directory of the originating file is not an ancestor directory of the target file\cite{web:mdn}. Because of the SOP, WSIs would have to be located in the directory structure of the AS, which by itself does not create a problem. To get a new WSI there, however, the user would be forced to navigate through the structure of the AS, find the correct directory and then place it there manually. This makes knowledge of the service structure necessary and creates a horrible UX. Furthermore, tinkering with the file structure of the AS creates a possible source for errors.

A workaround of this problem is to deploy a web server, which can redirect the image request, access the WSI and return it in response\cite{Tseytlin14}. The use of DZI creates another advantage: the used image pyramid model reduces the network traffic necessary to load and show a WSI in a viewer\cite{Cornish13}\cite{DICOM10}.

Furthermore, even a single WSI takes up a lot of storage capacity\cite{Singh11}. Having multiple WSIs on a local hard drive would either create the need for huge amounts of available storage space or restrict the amount of accessible WSIs to a few at any given time. The latter solution would create two follow-up problems:
\begin{itemize}
	\item WSIs are medical images and as such confidential information. Therefore, not everyone is allowed to just have access to or copies of them\cite{COA}\cite{USSanDiego}. Once a copy of a WSI changes hands, it is virtually impossible to make sure that privacy regulations will be uphold.	
	\item With only a small amount out of all WSIs accessible at all times, the need for copying files back and forth arises as soon as the user wants to compare, update or correct a WSI, which is not on his local file system at the given moment. Not only is this a great source for possible errors, but also very time consuming and inefficient.
\end{itemize}

With the use of a web server as a central image repository, WSIs and the access to them can be managed in a centralized spot, while upholding confidentiality regulations. Furthermore, a user has access to all of her/his WSIs at any given time, without the need for creating subsets and copying files back and forth. Depending on the setup of the network, other factors can come into play as well. Access to and sharing of rare cases, educational material and training samples can be granted without a complicated distribution chain and a smaller risk for confidentiality issues. It also enables the consultation of case experts independent of their physical position on the planet\cite{Wilbur09}.


\subsubsection{Annotation Service Server}
The ASS has 2 main purposes.

First, it serves as a so called \emph{Digital Slide Repository} (DSR)\nmc{DSR}{Digital Slide Repository}. A DSR manages storage of WSIs and their metadata. Additionally, it serves requested image data to a viewer client\cite{Cornish13}, such as the ASV. 

Second, it is responsible for file management. In detail, this means:
\begin{itemize}
	\item persist made annotations in a file
	\item deliver annotation data together with image data
	\item serve list of all available label dictionaries
	\item serve label dictionary entries
	\item save added entries to existing label dictionary
	\item create new, empty label dictionaries
\end{itemize} 

The development of a fully functional web server is not in the scope of this thesis. Therefore, the ASS will run as a local web server. This works around many of the common issues when hosting a web server\cite{web:typicalissues}, such as:

\begin{itemize}
	\item inefficient data or page caching
	\item firewall throughput
	\item internet access throughput
	\item load balance issues
	\item gateway issues
	\item poor security design
	\item connectivity issues
\end{itemize}


\subsubsection{Annotation Service Viewer}
The ASV is developed to deploy a GUI through which the pathologist is enabled to view a WSI and annotate it. The ASV is developed in an iterative approach with the help of selected pathologists. After each iteration, the GUI and user experience (UX)\nmc{UX}{User Experience} will be evaluated. This way, the ASV can be adapted to the needs of a real life environment based on the pathologists feedback.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.2]{img/microdrawUI.png}
		\caption{Microdraw GUI with opened WSI}
		\label{fig4_microdrawUI}
	\end{center}
\end{figure}

The first iteration of the ASV will be based on an open source project called \emph{MicroDraw}\footnote{See \url{https://github.com/r03ert0/microdraw} for more information on the MicroDraw project} (see fig. \ref{fig4_microdrawUI} for MicroDraws GUI).  MicroDraw is a web application to view and annotate \emph{"high resolution histology data"}\cite{web:microdraw2}. The visualization is based on another open source project, called \emph{OpenSeadragon}\cite{web:openseadragon}. Annotations are made possible by the use of \emph{Paper.js}\footnote{See \url{http://paperjs.org/} for more information on Paper.js}. This delivers a baseline for the functionality specified in \ref{sec4_functions} and can be further adjusted to the needs of the ASV.

Apart from the frameworks used, MicroDraw is written in JavaScript using HTML5, CSS3 and jQuery\footnote{See \url{https://jquery.com/} for more information on jQuery}.

\section{Annotation Service Server Implementation}
% uses json to save annotations and dictionaries
% internal structure

The ASS is a local RESTful server written in python (\emph{\textbf{as{\textunderscore}server.py}}). Additional frameworks have been used to improve functionality. Those are:

\begin{itemize}
	\item Flask\cite{web:flask} (see subsection \ref{sec4_flask})
	\item OpenSlide Python\cite{web:openslide} (see subsection \ref{sec4_openslide})
\end{itemize}

The use of the Flask framework makes a certain folder structure necessary\cite{web:flask}. To serve static files, a \emph{"static/"} directory must be present in the base directory of the ASS. The static/ directory contains the CSS, JavaScript, dictionaries and WSIs. To read a WSI with the ASS, it must be placed in static/wsi/[file path/]. The dictionaries can be found in static/dictionaries/, if a manual manipulation of a dictionary (deleting one or deleting/updating an entry in one) becomes necessary.

The ASS can be started from a terminal through the use of a python interpreter:
\begin{lstlisting}
	$ python as_server.py
\end{lstlisting}

Alternatively, python's -m switch can be used:
\begin{lstlisting}
	$ export FLASK_APP=as_server.py
	$ python python -m flask run
\end{lstlisting}

When started without further parameters, the server will listen to the IP 127.0.0.1, port 5000 by default. Another IP address or port can be specified via the -l and -p parameter (see tab. \ref{tab4_assParams} for a complete list of available parameters):
\begin{lstlisting}
	$ python as_server.py -l 192.27.119.89 -p 4711
\end{lstlisting}

\begin{table}[H]
	\begin{center}
		\begin{tabular}{| l | l | r |}
			\hline
			\textbf{parameter} & \textbf{description} & \textbf{default}\\ \hline
			-B, --ignore-bounds & render only the non-empty slide region & false\\ \hline
			-e, --overlap & set overlap between adjacent tiles in pixels & 0 \\ \hline
			-f, --format & set tile format (PNG or JPEG) & JPEG \\ \hline
			-l, --listen & set IP address to listen to & 127.0.0.1\\ \hline
			-p, --port & set port to listen to & 5000\\ \hline
			-Q, --quality & set JPEG compression quality in \% & 100\\ \hline
			-s, --size & set tile size & 256\\ \hline
		\end{tabular}
		\caption{Parameters for as{\textunderscore}server.py}
		\label{tab4_assParams}
	\end{center}
\end{table}

To access a WSI, the URL must be pointed to it, e.g. \url{http://127.0.0.1:5000/wsi/openslide/CMU-1.svs} to access the WSI CMU-1.svs in the directory static/wsi/openslide/.


\subsection{Flask}
\label{sec4_flask}
To give the ASS its server capabilities, Flask was used. Flask considers itself as \emph{"microframework"}, meaning that the development team tries to keep its core \emph{"simple, but extensible"}\cite{web:flask}. It contains a built-in development server, integrated unit testing, RESTful request dispatching and is fairly easy to set up and use. A minimal Flask application can look like this\footnote{The example application code snippet is taken from \cite{web:flask}}:

\begin{lstlisting}[frame=single]
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
return 'Hello, World!'

app.run(host='127.0.0.1', port='5000')
\end{lstlisting}

After the import of the Flask class (line 1), a Web Server Gateway Interface (WSGI)\nmc{WSGI}{Web Server Gateway Interface} object is created\footnote{The WSGI is a standard interface for the communication between web servers and web applications or frameworks in python. The interface has a server and application side. Basically, the server side invokes a callable object that is provided by the application side. The specifics of providing this object are up to the individual server\cite{Brandl16}.} (line 2). The defined \emph{hello\textunderscore}world function (line 5 and 6) is annotated with a \emph{route() decorator} to bind a specific URL to it (line 4). Once the specified URL is requested, Flask knows which function to invoke. Line 8 starts a local server listening on 127.0.0.1:5000.

As mentioned above, a \emph{route() decorator} (see fig. \ref{fig4_routeDecorator}) binds a URL to a function. When bound, the function will be called, once the specified URL is requested by the client\cite{web:flask}.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.5]{img/route.png}
		\caption{Hello, World! example on how to use Flasks route() decorator (source: \cite{web:flask})}
		\label{fig4_routeDecorator}
	\end{center}
\end{figure}

A bound URL can also contain variable sections, which are marked as \emph{/{\textless}variable name{\textgreater}}. Optionally, a converter can by used to only accept variables of a certain type. This becomes possible by specifying the converter in front of the variable: \emph{/{\textless}converter:variable name{\textgreater}}\cite{web:flask}. See tab. \ref{tab4_converter} for the list of available converters in Flask.

\begin{table}[H]
	\begin{center}
		\begin{tabular}{| l | l |}
			\hline
			\textbf{name} & \textbf{accepted input}\\ \hline
			string & any text without a slash (default)\\ \hline
			int & integer values\\ \hline
			float & floating point values\\ \hline
			path & like string, but also accepts slashes \\ \hline
			any & matches one of the items provided\\ \hline
			uuid & UUID strings\\ \hline
		\end{tabular}
		\caption{Available converters in Flask (source: \cite{web:flask})}
		\label{tab4_converter}
	\end{center}
\end{table}

To bind a URL with one or more variable sections to a function, the corresponding function must have the variable sections as parameters:

\begin{lstlisting}[frame=single]
@app.route('/<slug>_files/<int:level>/<int:col>_
<int:row>.<format>')
def tile(slug, level, col, row, format): ...
\end{lstlisting}

HTTP knows different methods for accessing URLs. By default, a route only answers to GET requests and refuses every other kind with a 405 HTTP status code. This can be changed by adding the \emph{methods} argument to the route() decorator (see fig. \ref{fig4_methods})\cite{web:flask}.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.5]{img/HTTPmethods.png}
		\caption{Example use of the method argument (source: \cite{web:flask})}
		\label{fig4_methods}
	\end{center}
\end{figure}

Through the use of decorators a RESTful API was deployed for the ASS (compare subsection \ref{sec4_api}).


\subsection{OpenSlide Python}
\label{sec4_openslide}
To read WSIs, the ASS uses OpenSlide Python, a python interface to the OpenSlide C library. It provides a simple interface for reading WSI. Additionally, it offers a DZI wrapper\cite{web:openslide}, called \emph{DeepZoomGenerator} (DZG)\nmc{DZG}{DeepZoomGenerator}, which can be used to create Deep Zoom tiles on demand. WSIs of the following formats are supported:

\begin{itemize}
	\item BIF
	\item NDPI
	\item MRXS
	\item SCN
	\item SVS
	\item SVSLIDE
	\item TIF
	\item TIFF
	\item VMS
	\item VMU
\end{itemize}

Through OpenSlide, the ASS can read a proprietary WSI as a so called \emph{OpenSlide} object (see line 4). As such it has methods to access available metadata, image tiles, the thumbnail and associated images. This OpenSlide object can be wrapped with a DZG to enable DZI support\cite{web:openslide}. To do so, the OpenSlide object needs to be passed into the constructor of the DZG (see line 5), together with a number of optional parameters (see tab \ref{tab4_DZGparam} for parameters and their default values):

\begin{lstlisting}[frame=single]
from openslide import open_slide
from openslide.deepzoom import DeepZoomGenerator

slide = open_slide(slide path)
dzg = DeepZoomGenerator(slide[, tile_size, overlap, limit_bounds])
\end{lstlisting}

\begin{table}[H]
	\begin{center}
		\begin{tabular}{| p{2.5cm} | p{2cm} | p{5.5cm} |}
			\hline
			\textbf{parameter} & \textbf{type} & \textbf{description}\\ \hline
			osr & OpenSlide, ImageSlide & the slide object
			\\ \hline
			tile{\textunderscore}size & integer & the width and height of a single tile (254)\\ \hline
			overlap & integer & the number of extra pixels to add to each interior edge of a tile (1)\\ \hline
			limit{\textunderscore}bounds & boolean & true to render only the non-empty slide region (false)\\ \hline
		\end{tabular}
		\caption{DeepZoomGenerator parameters (with default values, source: \cite{web:openslide})}
		\label{tab4_DZGparam}
	\end{center}
\end{table}

Once created, the DZG can give numerous informations about the tiles and levels of the wrapped WSI\footnote{See \cite{web:openslide} for an in-depth list of functions}. Of special importance are the \emph{get{\textunderscore}dzi} and \emph{get{\textunderscore}tile} functions. The get{\textunderscore}file(format) function creates a string, containing the metadata of the .dzi-file\footnote{See subsection \ref{sec2_openFormats} - Deep Zoom Images}. The \emph{format} parameter specifies the format of the individual tiles (PNG or JPEG). The get{\textunderscore}tile(level, address) function returns an image of the tile corresponding to the supplied parameter values (see tab. \ref{tab4_getTileParams}). The returned tile is either PNG or JPEG, depending on the value on the value passed to the format parameter of the get{\textunderscore}file function.

\begin{table}[H]
	\begin{center}
		\begin{tabular}{| p{1.5cm} | p{1.5cm} | p{7cm} |}
			\hline
			\textbf{name} & \textbf{type} & \textbf{description}\\ \hline
			level & integer & the DZI level to get the tile from \\ \hline
			address & tuple & the address of the thile within the level as a (column, row) tuple\\ \hline
		\end{tabular}
		\caption{DeepZoomGenerators get{\textunderscore}tile parameters (source: \cite{web:openslide})}
		\label{tab4_getTileParams}
	\end{center}
\end{table}

Through the use of those 2 functions, the ASS can create the metadata of a DZI on the fly and pass it to the ASV. The ASV then requests the individual tiles needed for the current view in return, which are generated by the DZG from the original WSI on demand.


\subsection{Annotation Service Server RESTful API}
\label{sec4_api}
To communicate with the ASS a RESTful API was deployed. This is realized with Flasks route() decorators\footnote{See subsection \ref{sec4_flask}}. The listing below gives an overview over the URLs that the ASS RESTful API offers (in the style of \textbf{URL} (method): \emph{function(parameters)}), followed by a brief description of the functionality\footnote{See appendix \ref{sec_B1} for a detailed documentation of the ASS functions}:

\begin{enumerate}[(1) -]
	\item\textbf{/wsi/{\textless}path:file{\textunderscore}path{\textgreater}.dzi} (GET): \emph{index{\textunderscore}dzi(file{\textunderscore}path)}\\
	This URL is used to request a viewer with a specified DZI from the ASS. The ASS then renders an ASV and passes the DZIs file path, its microns per pixel (MPP)\nmc{MPP}{Microns per Pixel} and its name to it. The ASV feeds the path to OpenSeadragon, which then views the DZI. The MPP are used to calculate the actual image size in $\mu$m for the scale. Lastly, the file name is used to change the name of the browser tab accordingly.
	
	\item \textbf{/wsi/{\textless}path:file{\textunderscore}path{\textgreater}} (GET): \emph{index{\textunderscore}wsi(file{\textunderscore}path)}\\
	Works similar to (1), except that the requested image is not of the DZI format. To view it in OpenSeadragon anyway, an instance of the DZG is created which wraps the proprietary WSI. Then, a specific path ("\emph{/slide.dzi}") is handed to the ASV.
	
	\item \textbf{/{\textless}slug{\textgreater}.dzi} (GET): \emph{dzi(slug)}\\
	Once the ASV requests slide.dzi, the DZG builds a response with the descriptive DZI file, created from the proprietary WSI format (via its \emph{.get{\textunderscore}dzi(format)} function, with \emph{format} being the file format of the tiles) and serves it to the ASV.
	
	\item \textbf{/{\textless}slug{\textgreater}{\textunderscore}files/{\textless}int:level{\textgreater}{\textunderscore}{\textless}int:col{\textgreater}{\textunderscore}{\textless}int:row{\textgreater}.{\textless}format{\textgreater}}\\(GET): \emph{tile(slug, level, col, row, format)}\\
	If an original DZI is requested, there is a \emph{/wsi/} in front of the URL. Therefore, this URL only triggers if (3) was called before. This way OpenSeadragon requests the separate tiles needed to fill the current view of the user. This is done via the DZG \emph{.get{\textunderscore}tile(level, address)} function. \emph{Level} describes the requested level, while \emph{address} is a tuple with the x (col) and y (row) position of the requested tile.
	
	\item \textbf{/saveJson} (POST): \emph{saveJson()}\\
	This URL is used when the user wants to save made annotations. The name of the JSON file and the content to write into it will be send via the POST request. The content of the POST request can be accessed via Flasks \emph{Request} object\cite{web:flask} in the following fashion:
	\begin{lstlisting}[frame=single]
	post_data = request.form
	source = post_data.get('file', default='')
	content = post_data.get('content', default='{}').
	encode('utf-8')
	\end{lstlisting}
	
	\item \textbf{/loadJson} (GET): \emph{loadJson()}\\
	(6) is used to load a JSON file, may that be the \emph{configuration.json}, a dictionary or saved annotations. The name of the source is passed as parameter (?src=[file]) to the ASS. Similar to (5), it can be accessed with the Request object\cite{web:flask}: \emph{request.args.get(parameter, default value)}.
	
	\item \textbf{/createDictionary} (GET): \emph{createDictionary()}\\
	If the user sends the command to create a new dictionary, this URL is called. The ASS then creates a new, empty dictionary file. The name of the dictionary is passed as a URL parameter (?name=[name]) and then acquired in the same fashion as in (5). The ASS also opens the configuration file and changes the currently selected dictionary to the newly created one.
	
	\item \textbf{/getDictionaries} (GET): \emph{getDictionaries()}\\
	When called, the ASS looks up the content of its \emph{dictionaries} folder and returns a list with the found file names or -1 in the case of an error.
\end{enumerate}


% python web server, flask, openslide, java script, html5, css, jquery
\section{Annotation Service Viewer Implementation}
% paper
% osd
% jquery
% functions?
% loading process
% inizialization of paper and openseadragon
